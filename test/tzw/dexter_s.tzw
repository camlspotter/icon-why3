scope Unknown

  predicate pre (c : ctx) =
    let token_pool, (_xtz_pool, token_contract) = c.Cpmm.store in
    let token_ledger, approval = c.Fa.store in
    token_contract = Fa.address /\
    approval[Cpmm.address] = const false /\
    token_pool.nat_v <= token_ledger[Cpmm.address].nat_v

  predicate post (_c : ctx) (c' : ctx) =
    let token_pool', (_xtz_pool', token_contract') = c'.Cpmm.store in
    let token_ledger', approval' = c'.Fa.store in
    token_contract' = Fa.address /\
    approval'[Cpmm.address] = const false /\
    token_pool'.nat_v <= token_ledger'[Cpmm.address].nat_v

end

scope Cpmm

  type param = (nat, (address, address))

  type store = (nat, (nat, address))

  predicate spec (st : step) (p : param) (s : store) (ops : list operation) (s' : store) =
    let token_pool, (xtz_pool, token_contract) = s in
    let token_pool', (xtz_pool', token_contract') = s' in
    let token_sold, (token_owner, receipient) = p in
    let b = div (token_sold.nat_v * xtz_pool.nat_v) (token_sold.nat_v + token_pool.nat_v) in
    token_sold.nat_v > 0 /\
    (*token_owner <> st.self /\*)
    token_pool'.nat_v = token_pool.nat_v + token_sold.nat_v /\
    xtz_pool'.nat_v = xtz_pool.nat_v - b /\
    token_contract = token_contract' /\
    ops = Cons (Xfer (Fa.gparam (Left (token_owner, (st.self, token_sold)))) (mk_mutez 0) token_contract)
                (Cons (Xfer (PUnit ()) (mk_mutez b) receipient)
                  Nil)

  let upper_ops = 2

  predicate pre (c : ctx) = inv_pre c

  predicate post (_st : step) (_p : param) (c : ctx) (c' : ctx) = inv_post c c'

end

scope Fa

  type param = (or (address, (address, nat)) address)

  type store = (map address nat, map address (map address bool))

  predicate spec (st : step) (p : param) (s : store) (ops : list operation) (s' : store) =
    let (ledger, approval) = s in
    let (ledger', approval') = s' in
    match p with
    | Left (_from, (to_, val_)) ->
      approval = approval' /\
      (let l = ledger[_from <- mk_nat (ledger[_from].nat_v - val_.nat_v)] in
         ledger' = l[to_ <- mk_nat (l[to_].nat_v + val_.nat_v)]) /\
      (_from = st.sender || approval[_from][st.sender]) /\ (val_.nat_v <= ledger[_from].nat_v) /\
      ops = Nil
    | Right spender ->
      ledger = ledger' /\
      approval[st.sender <- approval[st.sender][spender <- true]] = approval' /\
      ops = Nil
    end

  let upper_ops = 0

  predicate pre (_c : ctx) = true

  predicate post (st : step) (p : param) (c : ctx) (c' : ctx) =
    c.Cpmm.store = c'.Cpmm.store /\
    spec st p c.Fa.store Nil c'.Fa.store

end
